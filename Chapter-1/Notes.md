# 第1章 开始

我们通过编写一个简单的程序来开始对C++的学习。假设有一家书店现在需要一个程序来处理其销售记录，每条销售记录包含三个数据项：

**0-201-70353-X** **4** **24.99**

第一项是书的ISBN号，第二项是销售的册数，第三项是书的单价。

为了编写这个程序，需要用到C++的一些基本特性。并且容易得知，这个程序需要：

- 定义变量

- 进行输入和输出

- 使用数据结构保存数据

- 检测两条记录是否有相同的ISBN号

- 包含一个循环来处理所有的销售记录

## 1.1 编写一个简单的C++程序

每个C++程序都包含一个或多个函数（function）。其中必须有一个名为`main`的函数，操作系统通过调用`main`函数来运行C++程序。

一个简单的`main`函数如下所示：

```C++{.line-numbers}
int main()
{
    return 0;
}
```

函数的定义包含四部分：

- 返回类型（return type），在这里是`int`，即整数类型

- 函数名（function name）

- 形参列表（parameter list），包含在一对括号中，可以为空

- 函数体（function body），包含在一对花括号中

`main`函数虽然比较特殊，但除返回类型必须为`int`类型外，其定义方法与其他函数是一致的。

这个`main`函数非常简单，其唯一的功能就是通过`return`语句返回一个值为0的数。

在大多数操作系统中，`main`函数的返回值被用来指示状态。0表示成功，而-1表示失败（错误）。

注：

1.当`return`语句返回值时，这个值必须和函数的返回类型相容。例如在上面的程序中，`reutrn`返回0，而0恰好是一个`int`类型的值。

2.类型是程序设计中的一个基本概念。一种类型不仅定义了数据元素的内容，还定义了这类数据上可以运行的运算。程序中的数据都保存在变量中，而每个变量都有类型。

**编译、运行程序**

程序的源代码一般保存在源文件（source file）中。当程序的代码编写好后，就需要对其进行编译，以得到可被操作系统运行的程序。我们既可以通过IDE（集成开发环境）进行编译，又可以通过在命令行界面中调用编译器来进行编译。

这里以Linux操作系统为例，演示如何编译、运行上面的程序。

首先，需要用如下命令下载GNU编译器（使用的包管理器依具体的发行版而定）：

```{.line-numbers}
$ sudo dnf install gcc-c++
```

然后通过如下命令调用编译器，编译上面的代码：

```{.line-numbers}
$ g++ -o prog1 prog1.cc -Wall
```

其中`g++`是调用GNU编译器的命令，`-o prog1`表示将源文件编译为名为`prog1`的可执行文件，而`prog1.cc`是要编译的源文件。`-Wall`选项会检测代码中的错误，并在发生错误时给出错误信息，这有利于程序的调试，因此在编译时习惯上都会选用该选项。

在编译完成后，会得到名为`prog1`的可执行文件。可以通过如下命令来运行这个程序：

```{.line-numbers}
$ ./prog1
```

其中，`./`表示文件在当前目录下。

在Linux系统中，还可通过如下命令来获取程序的返回值：

```{.line-numbers}
$ echo $?
```

在运行上面的程序并输入上述命令后，就会得到返回值0。

## 1.2 初识输入输出

C++通过`iostream`标准库提供输入输出机制。`iostream`标准库包括`istream`和`ostream`两类对象，分别用来控制输入流和输出流。所谓流（stream），就是按顺序生成和消耗的字符序列。

**标准输入输出对象**

`iostream`标准库定义了四个输入输出对象：

- `cin`：标准输入，`istream`类对象，用于处理输入的数据。

- `cout`：标准输出，`ostream`类对象，用于处理输出的数据。

- `cerr`：标准错误，`ostream`类对象，用于输出警告和错误信息。

- `clog`：`ostream`类对象，用于输出程序运行时的一般性信息。

**一个使用IO库的程序**

对于我们要编写的书店程序而言，数据的输入和输出显然是必要的。在这里，我们先解决一个相关但简单的问题：编写一个程序，提示用户输入两个数，并输出它们的和。

```C++{.line-numbers}
#include <iostream>
int main()
{
    std::cout << "Enter two numbers: " << std::endl;
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout << "The sum of " << v1 << " and " << v2 
              << " is " << v1 + v2 << std::endl;
    return 0;
}
```

在编译并运行这个程序后，首先会在屏幕上输出文字：

`Enter two numbers: `

假设用户输入了：

`3 7`

在按下回车后，屏幕上就会显示程序运行的结果：

`The sum of 3 and 7 is 10`

注意到在代码的第一行，使用了`#include <iostream>`来指定使用`iostream`标准库，尖括号`<>`中的名字被称为头文件（header）。若在程序中使用了标准库，则必须要用`#include <标准库名>`来在代码中指定相关的头文件（头文件名就是标准库名）。且一般习惯将`#include`语句写在源文件的开始位置。

**向流写入数据**

`main`函数体中的第一个语句是：

```C++{.line-numbers}
std::cout << "Enter two numbers: " << std::endl;
```

这个语句执行了一个表达式（expression）。

**表达式：** 由一个或多个运算对象以及（通常是）一个运算符组成，执行后返回一个运算结果。

上述语句使用了输出运算符`<<`。输出运算符`<<`左侧的运算对象必须是一个`ostream`类对象，而右侧的对象是要输出的值。输出运算符`<<`会将右侧的值写入到左侧的`ostream`对象中，并返回左侧的`ostream`对象（即其左侧的`ostream`对象就是表达式的运算结果）。

不难看出，上述语句中的第一个输出运算符会将`"Enter two numbers: "`写入到标准输出流`cout`中，然后返回`cout`，返回的`cout`又将成为第二个输出运算符左侧的运算对象。而第二个输出运算符会将`endl`写入到`cout`中。这个语句事实上将两个表达式合并到一个语句中，我们也可以将这个语句分别写成两个两个语句：

```C++{.line-numbers}
std::cout << "Enter two numbers: ";
std::cout << std::endl;
```

第一条语句是向用户输出一行文字'Enter two numbers: '。第二条语句是向输出流`cout`中写入操纵符（manipulator）`endl`。`endl`的功能是向输出流中插入一个换行符（\n），并立刻刷新缓冲区（buffer）。

注：

1.表达式的运算对象不一定是数。

2.当我们进行输入输出操作时，由于处理器的运行速度快，输入输出设备的运行速度慢，为了协调这种运行速度差异，提高程序的运行效率，计算机会在内存中划出一块名为缓冲区的区域来临时存放输入输出的数据。例如，想象一下我们正在吃袋装零食，如果我们每吃一袋就要下楼扔一次垃圾，就太麻烦了。我们可以先把垃圾放在一个垃圾桶中，等吃完零食后再把垃圾桶中的垃圾处理掉。此时，零食包装袋就是需要输出的数据，而垃圾桶就是缓冲区。

**命名空间**

注意到先前在使用标准输出`cout`时，没有直接写`cout`，而是写了`std::cout`。前缀`std::`指出使用的名字`cout`是定义在名为`std`的命名空间（namespace）中的。

命名空间是C++的一个基本特性。C语言规定变量名不能和关键字冲突，但没有规定变量名不能和库中的变量名冲突。为了避免这种冲突，C++引入了命名空间，用于指定所使用名称的出处。标准库定义的所有名字都在命名空间`std`中。

在使用标准库中的名字时，必须显式地指出使用的名字来自于命名空间`std`。例如，要使用标准输出`cout`，就必须写`std::cout`，其中作用域运算符`::`的功能就是指定使用的名字`cout`来自命名空间`std`。

**从流读取数据**

在提示用户输入数字后，程序就需要读取用户输入的数字。

首先创建两个变量来保存用户输入的数字（程序中的数据都保存在变量中）：

```C++{.line-numbers}
int v1 = 0, v2 = 0;
```
我们创建了两个`int`型的变量`v1`和`v2`，并将其初始化（即在创建变量时为其赋予一个值）为0。

程序通过如下语句将数据保存在变量`v1`和`v2`中：

```C++{.line-numbers}
std::cin >> v1 >> v2;
```

输入运算符`>>`左侧的运算对象必须是一个`istream`类对象，其功能是将左侧`istream`类对象中的数据写入到右侧对象中，并返回左侧的`istream`对象（即其左侧的`istream`对象就是表达式的运算结果）。

上述语句中的第一个输入运算符会将标准输入`cin`中保存的第一个数写入到变量`v1`中，然后返回`cin`，而`cin`又将成为第二个输入运算符左侧的运算对象。第二个输入运算符则会将`cin`中保存的第二个数写入到变量`v2`中。简单来说，上述语句的功能就是从标准输入`cin`中读取两个数，并将第一个数写入到`v1`中，将第二个数写入到`v2`中。这条语句和下面的两条语句是等价的：

```C++{.line-numbers}
std::cin >> v1;
std::cin >> v2;
```

**完成程序**

在读取用户输入的两个数后，程序就可以输出运算的结果：

```C++{.line-numbers}
std::cout << "The sum of " << v1 << " and " << v2 
          << " is " << v1 + v2 << std::endl;
```

尽管与之前的输出语句相比，这条语句要更长，但其功能也非常容易理解，即按顺序将`"The sum of "`，`v1`，`" and "`等值写入到标准输出`cout`中。

## 1.3 注释

注释（comments）的作用是帮助人类理解代码，通常用于概述算法，说明变量的用途和解释晦涩难懂的代码段。编译器在编译时会忽略掉注释。

**C++中注释的种类**

C++中的注释有两种。

**单行注释：** 以双斜线`//`开始，以换行符结束。单行注释中可以包含任何文本，包括额外的双斜线。

**多行注释：** 以`/*`开始，以`*/`结束（`/*`和`*/`称为注释界定符），其中可以包含除`/*`和`*/`以外的任意内容，包括换行符。编译器会将`/*`和`*/`之间的内容都当作注释。

在使用多行注释时，最好指明多行注释中的程序行是注释的一部分，常用的方法是在多行注释中每一行的开头写一个星号`*`。

```C++{.line-numbers}
#include <iostream>
/*
* 简单main函数：
* 读取两个数，并求它们的和。
*/
int main()
{
    // 提示用户输入两个数。
    std::cout << "Enter two numbers: " << std::endl;
    int v1 = 0, v2 = 0;// 保存输入的数据的变量。
    std::cin >> v1 >> v2;// 读取输入数据。
    std::cout << "The sum of " << v1 << " and " << v2 
              << " is " << v1 + v2 << std::endl;
    return 0;
}
```
**多行注释不能嵌套**

一个多行注释不能嵌套在另一个多行注释中，否则编译器会报错。这是因为多行注释是以`/*`开始，以`*/`结束的，如果将一个多行注释嵌套在另一个多行注释中，那么编译器就无法理解注释从哪里开始，到哪里结束。若编译下面的代码，则编译器会报错：

```C++{.line-numbers}
/*
* 注释界定符对/* */不能嵌套。
* “不能嵌套”几个字会被编译器认为是源码，
* 像剩余代码一样处理，编译时就会报错。
*/
int main()
{
    return 0;
}
```

当我们在调试程序时，经常会注释掉一些代码。考虑到这些代码中可能会包含多行注释，因此注释这些代码最好的方法是在代码中每一行的开头加上双斜线（即用单行注释的方式来注释掉需要注释的代码）。

```C++{.line-numbers}
// /*
// * 单行注释中的任何内容都会被忽略。
// * 包括嵌套的注释界定符对也一样会被忽略。
// */
```

## 1.4 控制流

语句一般是按顺序执行的。而C++提供了几种控制流语句，允许我们写出更为复杂的语句执行路径。

### 1.4.1 while语句

`while`语句会反复执行一段代码，直至条件为假。可以利用`while`语句编写一个程序，求1到10的和。

```C++{.line-numbers}
#include <iostream>
int main()
{
    // sum用于保存求和的结果，val用于表示1到10这10个数。
    int sum = 0, val = 1;
    // 只要val的值小于等于10，while语句就会持续执行。
    while (val <= 10) {
        sum += val;// 将sum + val赋给sum。
        ++val;// 将val加1。
    }
    std::cout << "Sum of 1 to 10 inclusive is " << sum << std::endl;
    return 0;
}
```

可以看出程序中包含了一段`while`语句。`while`语句的结构为：

```C++{.line-numbers}
while (condition)
    statement
```
`while`语句会交替检测`condition`和执行`statement`。条件（condition）就是一个会产生真假结果的表达式。当`condition`为真时，就会执行`statement`。在执行完`statement`后，`while`语句又会检测`condition`是否为真，若为真，则继续执行`statement`，若为假，则结束`while`语句。

在上面的例子中，`while`语句的结构为：

```C++{.line-numbers}
// 只要val的值小于等于10，while语句就会持续执行。
while (val <= 10) {
        sum += val;// 将sum + val赋给sum。
        ++val;// 将val加1。
}
```
`while`语句的条件使用小于等于运算符（`<=`）来检测`val`是否小于等于10。当`val`小于等于10时，条件为真，就会执行`while`循环体。在这里，`while`循环体是由两条语句组成的语句块（由一对花括号所包围的语句的集合）。

```C++{.line-numbers}
{
    sum += val;// 将sum + val赋给sum。
    ++val;// 将val加1。
}
```

第一条语句使用了复合赋值运算符（`+=`），求出`sum`和`val`的和，并将结果保存在`sum`中。这条语句和`sum = sum + val;`是等价的。

第二条语句使用了递增运算符（`++`），将`val`的值加1。`++val`和`val = val + 1;`是等价的。

当执行完`while`循环体后，`while`语句会再次检测条件是否为真（注意此时`val`的值已加1）。当`val`仍小于等于10时，会继续执行`while`循环体。当`val`大于10时，程序就会结束执行`while`循环，继续执行接下来的语句。

### 1.4.2 for语句

在`while`语句中，采用了在循环条件中检测变量，在循环体中递增变量的模式。C++中定义了另一种语句——`for`语句来简化这种循环。可以使用`for`语句重写计算1到10的和的程序：

```C++{.line-numbers}
#include <iostream>
int main()
{
    int sum = 0;// sum用于保存求和的结果。
    for (int val = 1; val <= 10; ++val)
        sum += val;// 等价于sum = sum + val。
    std::cout << "Sum of 1 to 10 inclusive is " << sum << std::endl;
    return 0;
}
```

与先前一样，我们定义了`int`型变量`sum`来保存求和结果。而变量`val`的定义则成为`for`语句的一部分。

```C++{.line-numbers}
for (int val = 1; val <= 10; ++val)
    sum += val;// 等价于sum = sum + val。
```

`for`语句的定义由两部分组成：循环头和循环体。循环头用于控制循环次数，包括一个初始化语句（init-statement）、一个循环条件（condition）以及一个表达式（expression）。

在本例中，初始化语句是：

```C++{.line-numbers}
int val = 1;
```

这一初始化语句创建了一个`int`型变量`val`，并将其值初始化为1。与`while`循环的例子不同的是，`for`循环初始化语句定义的变量`val`只能在循环中使用，在循环外无法使用。初始化语句只在`for`循环开始时执行一次。

在本例中，循环条件是：

```C++{.line-numbers}
val <= 10;
```

当`val`的值小于等于10时，条件为真，程序会执行`for`循环体中的语句。

在本例中，表达式是：

```C++{.line-numbers}
++val
```

表达式会在`for`循环体之后执行。本例中的表达式同样是使用递增运算符（`++`）将`val`的值加1。在执行完表达式后，`for`语句会重新检测循环条件，若`val`的新值仍小于等于10，则继续执行`for`循环体，若`val`的值大于10，则结束`for`循环，继续执行接下来的语句。

简要总结一下本例中`for`循环的执行过程：

1.执行初始化语句，创建变量`val`并将其值初始化为1。

2.检测循环条件。若`val`的值小于等于10，则执行`for`循环体，否则结束循环，执行`for`循环后的第一条语句。

3.执行表达式，将`val`的值加1。

4.重复第2步，检测循环条件，只要条件为真，就继续执行接下来的步骤。

注：

1.初始化语句、循环条件和表达式之间是用分号而不是逗号分隔。

2.初始化语句和表达式可以为空。

### 1.4.3 读取数量不定的输入数据

我们已经编写了一个求从1到10这10个整数的和的程序。我们可以对这个程序进行扩展，编写一个求用户输入的数的和的程序。与先前的情况不同的是，我们事先并不知道会读取多少个数，程序需要一直对输入的数进行求和，直至没有新的输入为止。

```C++{.line-numbers}
#include <iostream>
int main()
{
    // sum用于保存求和的结果，value用于保存用户输入的数。
    int sum = 0, value = 0;
    // 持续求和直至没有新的输入。
    while (std::cin >> value) 
        sum += value;// 等价于sum = sum +value。
    std::cout << "Sum is: " << sum << std::endl;
    return 0;
}
```

如果输入：

`3 4 5 6`

则程序会输出：

`Sum is: 18`

在这里，我们使用变量`value`保存用户输入的每个数。而数据的读取操作是在`while`循环的条件中完成的：

```C++{.line-numbers}
while (std::cin >> value)
```

注意到`while`循环的条件是表达式

```C++{.line-numbers}
std::cin >> value
```

输入运算符`>>`会将用户输入的数保存在变量`value`中，并返回左侧的`std::cin`。也就是说，表达式的运算结果就是`std::cin`。`while`循环的条件实际上是在检测`std::cin`。

当一个`istream`对象作条件时，条件实际上是在检测流的状态。若流没有错误，则`istream`对象有效，条件为真。当遇到文件结束符（end-of-file）或无效输入（例如读取的值不是一个整数）时，`istream`对象的状态会变为无效，此时条件为假。

本例中的`while`循环会一直执行至遇到文件结束符或无效输入。`while`循环体使用复合赋值运算符（`+=`）将当前`value`的值加到`sum`上。在`while`循环结束后，程序就会输出求和的结果。

### 1.4.4 if语句

C++提供了`if`语句来实现条件执行，即当条件为真时，执行`if`语句中的内容，否则不执行。

可以利用`if`语句编写一个程序，统计用户输入的某个数连续出现的次数。

```C++{.line-numbers}
#include <iostream>
int main()
{
    // currVal用于表示当前正在统计的数，val用于保存用户输入的数。
    int currVal = 0, val = 0;
    // 读取第一个输入的数，且只有在有输入时才会执行if语句中的内容。
    if (std::cin >> currVal) {
        int cnt = 1;// 变量cnt作为计数器，统计用户输入的数连续出现的次数。
        // 利用while循环连续读取用户输入的数。
        while (std::cin >> val) {
            if (val == currVal) // 如果用户输入的数和当前值相同。
                ++cnt;// 连续出现的次数+1。
            else {  // 如果用户输入的数和当前值不同，则意味着用户输入了新的数。
                // 输出当前值连续出现的次数。
                std::cout << currVal << " occurs " << cnt
                          << " times" << std::endl;
                // 将val赋给currVal，表示开始统计下一个数连续出现的次数。
                currVal = val;
                cnt = 1;// 重置计数器。

            }
        }// while语句在此结束。
        // 输出用户输入的最后一个数连续出现的次数。
        std::cout << currVal << " occurs " << cnt
                  << " times" << std::endl;
    }// 最外层的if语句在此结束。
    return 0;
}
```
与之前的程序相比，该程序中新的内容就是两个`if`语句。其中第一个`if`语句

```C++{.line-numbers}
if (std::cin >> currVal) {
    // ...
}
```
的条件是`std::cin >> currVal`，该条件只有在有初始输入时才为真，换言之，只有当有数据输入时，`if`语句中的内容才会被执行。

第二个`if`语句包含在`while`循环体中：

```C++{.line-numbers}
if (val == currVal) // 如果用户输入的数和当前值相同。
    ++cnt;// 连续出现的次数+1。
else {  // 如果用户输入的数和当前值不同，则意味着用户输入了新的数。
    // 输出当前值连续出现的次数。
    std::cout << currVal << " occurs " << cnt
              << " times" << std::endl;
    // 将val赋给currVal，表示开始统计下一个数连续出现的次数。
    currVal = val;
    cnt = 1;// 重置计数器。
}
```

在第二个`if`语句的条件`val == currVal`中，程序使用了相等运算符（`==`）来检测`val`是否和`currVal`相等。若二者相等，则执行`if`后的语句，使`cnt`（计数器）的值加1。若二者不相等，则执行`else`之后的语句块，输出当前值连续出现的次数，并做好统计下一个数连续出现的次数的准备。

并且，要注意到，在`while`语句结束后，最后一个`currVal`连续出现的次数没有被输出，因此需要在`while`语句之后，将最后一个`currVal`连续出现的次数输出。

注：

1.在C++中，使用`=`进行赋值，使用`==`判断两个对象的值是否相等。一个常见的错误是在条件中将`==`误用成`=`。
2.C++中没有强制的缩进格式要求，但习惯上会做适当的缩进，以使得代码结构更清晰，提升代码可读性。

## 1.5 类简介

为了完成书店程序，我们还需要定义一个数据结构（data structure）来表示销售数据。在C++中，可以通过定义一个类（class）来定义一个数据结构。一个类定义了一个数据类型，及其相关的一组操作。

为了使用一个类，我们需要知道：

- 类名是什么？

- 类在哪里定义？

- 这个类支持什么操作？

在这里，假定要使用的类名为`Sales_item`，它定义在头文件`Sales_item.h`中。

为了在程序中访问定义类的头文件，需要在代码中使用`#include "头文件名"`。头文件一般用其中定义的类名来命名，其后缀通常是`.h`（实际上，大多数情况下对头文件的文件格式不会有强制性的要求，甚至`.txt`文件也可以作为头文件使用）。

### 1.5.1 Sales_item类

`Sales_item`类的作用是表示一本书的总销售额、售出册数和平均售价。在这里，我们暂且不需要知道`Sales_item`类是如何实现的，只需要知道`Sales_item`类的对象可以执行什么操作。

每个类实际上都定义了一个新的数据类型，类型名就是类名。因此，`Sales_item`类定义了一个名为`Sales_item`的类型。当我们写出

```C++{.line-numbers}
Sales_item item;
```
时，我们就定义了一个名为`item`的`Sales_item`类的变量（对象）。

`Sales_item`类对象可以执行如下操作：

- 调用名为`isbn`的函数从一个`Sales_item`类对象中提取ISBN号。

- 使用输入运算符`>>`和输出运算符`<<`读、写`Sales_item`类对象。

- 使用赋值运算符`=`将一个`Sales_item`类对象的值赋给另一个`Sales_item`类对象。

- 使用加法运算符`+`将两个`Sales_item`类对象相加。两个对象必须表示同一本书（有着相同的ISBN号），加法运算的结果是一个新的`Sales_item`类对象，其ISBN号与两个运算对象相同，总销售额和售出册数则等于两个运算对象的对应值之和。

**读写Sales_item**

下面的程序会从标准输入中读取销售记录，保存到一个`Sales_item`类对象中，并输出。

```C++{.line-numbers}
#include <iostream>
#include "Sales_item.h" // 注意使用#include语句指定头文件Sales_item.h。
int main()
{
    Sales_item book;
    // 读取并写入
    std::cin >> book;
    // 输出Sales_item类变量中保存的数据（ISBN号、总售出册数、总销售和和平均价格）。
    std::cout << book << std::endl
    return 0;
}
```

如果输入

`0-201-70353-X 4 24.99`

则会输出

`0-201-70353-X 4 99.96 24.99`

输入表示书店以24.99美元的价格售出了4册书。输出表示这本书总售出册数是4，总销售额是99.96美元，平均售价是24.99美元。

**Sales_item对象的加法**

下面的程序会在读取两条销售记录后将其相加。

```C++{.line-numbers}
#include <iostream>
#include "Sales_item.h"
int main()
{
    Sales_item item1, item2;
    std::cin >> item1 >> item2;
    std::cout << item1 + item2 << std::endl;
    return 0;
}
```

如果输入

`0-201-78345-X 3 20.00`
`0-201-78345-X 2 25.00`

则会输出

`0-201-78345-X 5 110 22`

注：

通过文件重定向操作，可以实现在运行程序时从一个文件读取输入数据，并将输出结果保存在另一个文件中的效果。

Linux系统中文件重定向的命令为：

```{.line-numbers}
$ ./addItems <infile >outfile
```
上述命令会运行名为`addItems`的文件，且会从名为`infile`的文件中读取输入数据，并将输出结果保存到名为`outfile`的文件中。两个文件都位于当前目录中，并且`outfile`可以不预先创建。

### 1.5.2 初识成员函数

**成员函数：** 成员函数是在类的定义内部声明和定义的函数。成员函数可以操作类的任意对象，以及访问类对象的成员。

要将两个`Sales_item`类对象相加，首先需要检查这两个`Sales_item`类对象是否有相同的ISBN号（如果ISBN号相同，则表示二者是同一本书的两条销售记录，应该合并）。通过调用定义在`Sales_item`类中的名为`isbn`的成员函数，就可以实现这一点。

```C++{.line-numbers}
#include <iostream>
#include "Sales_item.h"
int mian()
{
    Sales_item item1, item2;
    std::cin >> item1 >> item2;
    // 检查两条销售记录是否有着同样的ISBN号。
    if (item1.isbn() == item2.isbn()) {
        //若相同，则将两条销售记录合并后输出。
        std::cout << item1 + item2 << std::endl;
        return 0;// 表示程序运行成功。
    }
    else {
        std::cerr << "Data must refer to same ISBN" << std::endl;
        return -1;// 表示程序运行失败。
    }
}
```

上述代码中`if`语句的条件`item1.isbn() == item2.isbn()`调用了名为`isbn`的成员函数。

我们通常用一个类对象来调用成员函数。上述条件的左侧

```C++{.line-numbers}
item1.isbn()
```

使用了点运算符`.`来表达“获取名为`item1`的`Sales_item`对象的`isbn`成员”。点运算符只能作用于类类型的对象，其左侧运算对象必须是一个类类型对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员名。

当我们访问一个成员函数时，实现的效果就是调用该成员函数。我们通过调用运算符`()`来调用函数。调用运算符的内部用于放置实参（argument）列表（可能为空）。因此，

```C++{.line-numbers}
item1.isbn()
```

会调用名为`isbn`的成员函数，并返回保存在`item1`中的ISBN号。

综上所述，

```C++{.line-numbers}
item1.isbn() == item2.isbn()
```
会比较`item1`和`item2`中保存的ISBN号，若相同，则条件为真，若不同，则条件为假。

## 1.6 书店程序

利用之前所学的知识，我们现在可以完成一个读取、处理和输出销售数据的书店程序。

在这里，我们假设同一本书（ISBN号相同）的所有销售记录是保存在一起的。

```C++{.line-numbers}
#include <iostream>
#include "Sales_item.h"
int main()
{
    Sales_item total;// Sales_item对象total用于保存最终的销售数据。
    // 检测是否有初始输入，并将初始输入保存到total中。
    if (std::cin >> total) {
        Sales_item trans;// Sales_item对象trans用于保存新输入的销售记录。
        // 通过while循环不断读取销售记录。
        while (std::cin >> trans) {
            // 检测新输入的销售记录和当前处理的销售记录是否有着相同的ISBN号。
            if (total.isbn() == trans.isbn())
                total += trans;// 若ISBN号相同，则合并销售记录。
            else {
                // 若ISBN号不同，则意味着输入了新书的销售记录。
                // 输出当前处理的书最终的销售数据。
                std::cout << total << std::endl;
                total = trans;// 将trans的值赋给total，开始处理下一本书。
            }
        }
        // 输出最后一本书的销售数据。
        std::cout << total << std::endl;
    }
    // 若没有初始输入，则输出一条错误信息。
    else {
        std::cerr << "No Data?!" << std::endl;
        return -1;// 表示程序运行失败。
    }
    return 0;// 表示程序运行成功。
}
```

我们可以参考1.4.4节和1.5.2节的程序。这个书店程序使用`total`保存最终的销售数据，并通过最外层`if`语句的条件来完成初始输入的检测和写入。若没有数据输入，则直接跳到后面的`else`语句，输出一条错误信息，提示用户没有数据输入。若初始输入成功，则创建变量`trans`来保存后续输入的销售记录，并和之前一样，通过`while`循环不断读取销售记录。若新输入记录的ISBN号和当前记录的ISBN号相同，则表示是同一本书的销售记录，将二者合并（`total += trans;`）；若新输入记录的ISBN号和当前记录的ISBN号不同，则当前书的销售记录已处理完毕，且输入了下一本书的销售记录，需要将当前书最终的销售记录输出，并更新`total`（`total = trans;`），做好处理下一本书销售记录的准备。

此外，还需要注意，在`while`循环结束后，`total`中还保存着最后一本书的销售数据，因此还需要在`while`循环结束后，将最后一本书的销售数据输出。

若已事先将所有销售记录保存在一个文件中，则可以通过文件重定向操作，从文件中快速读取销售记录，并将结果保存在另一个文件中。